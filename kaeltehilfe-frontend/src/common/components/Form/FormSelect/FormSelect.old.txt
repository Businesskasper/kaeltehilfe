import {
  Combobox,
  Input,
  InputBase,
  MantineStyleProp,
  ScrollArea,
  TextInput,
  useCombobox,
} from "@mantine/core";
import { useForm } from "@mantine/form";
import React from "react";
import { ValueTypeProps } from "../../../utils";

import "./FormSelect.scss";

export type FormSelectProps<T extends { [key in string]: unknown }> = {
  items: Array<T>;
  valueGetter:
    | ValueTypeProps<T, string | undefined>
    | ((item: T) => string | undefined); // TODO of type
  disabledGetter?: ValueTypeProps<T, boolean> | ((item: T) => boolean); // TODO of type
  sort?: boolean;
  style?: MantineStyleProp;
  classNames?: string;
  onItemSelected?: (item: T | undefined) => void;
  formProps: ReturnType<ReturnType<typeof useForm>["getInputProps"]>;
  searchable?: boolean;
};

export const FormSelect = <T extends { [key in string]: unknown }>({
  items,
  valueGetter,
  disabledGetter,
  sort,
  style,
  classNames,
  onItemSelected,
  formProps,
  searchable,
}: FormSelectProps<T>) => {
  const getItemValue = React.useCallback(
    (item: T) => {
      return (
        (typeof valueGetter === "function"
          ? valueGetter(item)
          : (item[valueGetter] as string | undefined)) || ""
      );
    },
    [valueGetter]
  );

  const getItemDisabled = React.useCallback(
    (item: T) => {
      return !disabledGetter
        ? false
        : typeof disabledGetter === "function"
        ? disabledGetter(item)
        : (item[disabledGetter] as boolean); // TODO: find out why casting is necessary
    },
    [disabledGetter]
  );

  const combobox = useCombobox({
    onDropdownClose: () => combobox.resetSelectedOption(),
    loop: true,
    scrollBehavior: "smooth",
  });

  const options = React.useMemo(() => {
    const selectableItems = items.map((item) => ({
      value: getItemValue(item),
      isDisabled: getItemDisabled(item),
      item,
    }));
    return sort
      ? selectableItems.sort((a, b) => a.value.localeCompare(b.value))
      : selectableItems;
  }, [getItemDisabled, getItemValue, items, sort]);

  // const shouldFilterOptions = !options.some(
  //   (option) => option.value === formProps.value
  // );
  // const filteredOptions = React.useMemo(() => {
  //   return shouldFilterOptions
  //     ? options.filter((option) =>
  //         option.value
  //           .toLowerCase()
  //           .includes(formProps.value.toLowerCase().trim())
  //       )
  //     : options;
  // }, [formProps.value, options, shouldFilterOptions]);

  const [searchValue, setSearchValue] = React.useState(formProps.value || "");
  React.useEffect(() => {
    setSearchValue(formProps.value);
  }, [formProps.value]);

  const filteredOptions = React.useMemo(() => {
    return searchValue
      ? options.filter((option) =>
          option.value.toLowerCase().includes(searchValue.toLowerCase().trim())
        )
      : options;
  }, [searchValue, options]);

  console.log("value", formProps.value);
  return (
    <Combobox
      store={combobox}
      onOptionSubmit={(val, prop) => {
        formProps.onChange(prop.children);
        onItemSelected && onItemSelected(val as unknown as T | undefined);
        combobox.closeDropdown();
      }}
      withinPortal={false}
    >
      <Combobox.Target withKeyboardNavigation>
        {searchable ? (
          <TextInput
            classNames={{ root: `form-select ${classNames}` }}
            style={style}
            placeholder="Bitte auswählen"
            value={searchValue}
            onChange={(event) => {
              setSearchValue(event.target.value || "");
              // formProps.onChange(event);
              // setValue(event.currentTarget.value);
              combobox.openDropdown();
              // combobox.updateSelectedOptionIndex();
              // combobox.clickSelectedOption();
            }}
            onClick={() => combobox.openDropdown()}
            onFocus={() => combobox.openDropdown()}
            onBlur={() => {
              combobox.closeDropdown();
              if (searchValue !== formProps.value) {
                setSearchValue("");
              }
              formProps.onBlur && formProps.onBlur();
              // if (formProps.value && !shouldFilterOptions) {
              //   onItemSelected &&
              // }
            }}
          />
        ) : (
          <InputBase
            classNames={{ root: `form-select ${classNames}` }}
            style={style}
            component="button"
            type="button"
            pointer
            rightSection={<Combobox.Chevron />}
            rightSectionPointerEvents="none"
            onClick={() => combobox.toggleDropdown()}
          >
            {formProps.value || (
              <Input.Placeholder>Bitte auswählen</Input.Placeholder>
            )}
          </InputBase>
        )}
      </Combobox.Target>
      <Combobox.Dropdown>
        <Combobox.Options>
          <ScrollArea.Autosize mah={200} type="scroll">
            {filteredOptions.map((option, index) => {
              return (
                <Combobox.Option
                  value={option.item as unknown as string}
                  disabled={option.isDisabled}
                  key={`${option.value}_${index}`}
                >
                  {option.value}
                </Combobox.Option>
              );
            })}
          </ScrollArea.Autosize>
        </Combobox.Options>
      </Combobox.Dropdown>
    </Combobox>
  );
};
